<!DOCTYPE html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]>      <html class="no-js"> <!--<![endif]-->
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title></title>
    <meta name="description" content="" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="" />
  </head>
  <body>
    <!--[if lt IE 7]>
      <p class="browsehappy">
        You are using an <strong>outdated</strong> browser. Please
        <a href="#">upgrade your browser</a> to improve your experience.
      </p>
    <![endif]-->
    <div id="example">
      <!-- <my-slot>
        <div slot-scope="scope">
          我会被放到插槽里,我可以访问子组件的变量{{scope.nickname}}
        </div>
      </my-slot>
      <myslot2 ref="w1">
        <div slot-scope="scope">
          我会被放到插槽里,我是用函数式编程的作用域插槽，我可以访问子组件的变量{{scope.text}}
        </div>
      </myslot2> -->
      <!-- <myslot2 ref="w1">
        <div slot-scope="scope">
          我会被放到插槽里,我是用函数式编程的作用域插槽，我可以访问子组件的变量{{scope.text}}
        </div>
      </myslot2> -->
      <myslot>
        <template v-slot:wei>1111111111</template>

      </myslot>
    </div>
    <script src="../vuedebug/vue.js"></script>
    <script type="text/javascript" src="../vuedebug/libs/loglevel.js"></script>
    <script>
      // Vue.component("my-slot", {
      //   data: function () {
      //     return {
      //       count: 0,
      //     };
      //   },
      //   created() {
      //     console.log(this.$slots);
      //     console.log(this.$scopedSlots);
      //   },
      //   mounted() {
      //     console.log(this.$slots);
      //     console.log(this.$scopedSlots);
      //   },
      //   template: `<div><p>weidehai</p><slot :nickname="'wdh'"></slot></div>`, //这样是吧作用插槽写在了模板中，由vue的编译器来编译模板
      //   //还有一种方法就是用编程式，也就是函数式的方式来定义作用域插槽
      // });
      // Vue.component("myslot2", {
      //   render: function (createElement) {
      //     var he = createElement("div", {
      //       domProps: { innerHTML: "this child div" },
      //     });
      //     return createElement("div", [
      //       he,
      //       //this.$slots.default,   //createElement会创建vnode，这个vnode等到patch的时候会用来比较，发现新老vnode不一样就会patch生成真实的node，真实的node是通过vnode来生成的
      //       // 如果不写this.$slots.default，那么这个组件的子内容下就不会存到vnode内，patch的时候就渲染不到
      //       this.$scopedSlots.default({
      //         text: "hello scope", //这里就是要绑定到插槽上的对象
      //       }),
      //     ]);
      //   },
      // });
      Vue.component('myslot',{
        template:`<div>11111<slot name="wei"></slot></div>`
      })
      new Vue({
        el: "#example",
        created() {},
        mounted() {
          console.log(this.$refs);
        },
      });
    </script>
  </body>
</html>
